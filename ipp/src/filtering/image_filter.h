#pragma once
#include "image.h"
#define THRESH_OPTIMAL 0.055 // adaptive thresholding: 5.5% below local mean

typedef unsigned int u32;
typedef unsigned char u8;

/*
 * FilterImage(Image* image, u32* tmp, int flags)
 *
 * Prepares the input image for binarization by appling noise reduction filters.
 * The following filters are applied to the input image (in order):
 * - Grayscale
 * - Stretch Contrast
 * - Median Filter
 * - Bilateral Filter
 *
 * Note that `tmp` must have the same size as `image->pixels`. Indermediate
 * results can be generated by providing the field `flags` (see utils.c).
 */
void FilterImage(Image* image, u32* tmp, int flags);

/*
 * BinarizeImage(Image* image, u32* tmp, float threshold)
 *
 * Applies a binarization to the provided image using an adaptive thresholding
 * method that removes all pixels that are off by `threshold` percent of the
 * local mean (calculated in a window of 15x15). The result is then dilated to
 * fill the possible gaps generated by the thresholding process. Note: tmp must
 * have the same size as `image->pixels`, any data in tmp may be changed.
 */
void BinarizeImage(Image* image, u32* tmp, float threshold);

/*
 * CleanCell(const Image* cell, u8* markers) -> bool
 * [Prepare cell for OCR]
 *
 * Returns true if the cell may contain a digit. The function always applies a
 * circle mask to the input image in order to avoid any unwanted border
 * leftovers. In this context, the image is considered as a graph. The presence
 * of a digit is inferred from the size of the largests connected components
 * satisying or not a certain fill threshold.
 */
int CleanCell(Image* img, u32* markers);

/*
 * PrepareCell(const Image* cell, u8* markers) -> double*
 * [Prepare cell for OCR]
 *
 * Returns a new 28x28 image that contains a resized and cropped version of the
 * digit stored in the input image `cell`. The parameter `markers`  refers to
 * the components of the cell that are kept as they may be part of the digit.
 * Note that `markers` is generated by the CleanCell function and must have the
 * same size as `cell->pixels`.
 */
double* PrepareCell(const Image* cell, const u32* markers);

/*
 * GrayscaleFilter(Image* image, u8* min, u8* max)
 *
 * Converts in-place the input colored image in a grayscale image.
 */
void GrayscaleFilter(Image* image, u8* min, u8* max);

/*
 * StretchContrast(Image* img, u8 min, u8 max)
 *
 * Normalizes the pixel values of the image by changing the range of values of
 * the image so that the value 0 represents a pixel value of `min` and the value
 * 255 represents a pixel value of `max`.
 */
void StretchContrast(Image* img, u8 min, u8 max);

/*
 * AutoBrigthness(Image* image, float clip)
 *
 * Performs an histogram equalization with a certain clip threshold on the image
 * in order to harmonize the brightness of the image. Note that clip is
 * normalized number (0-100% <=> 0-1).
 */
void AutoBrigthness(Image* image, float clip);

/*
 * FillHistogram(const Image* image, u32 histogram[256])
 *
 * Generates the histogram of the provided image. Used in the histogram-based
 * algorithms such as Otsu Thresholding and AutoBrightness.
 */
void FillHistogram(const Image* image, u32 histogram[256]);

/*
 * ComputeOtsuThreshold(size_t len, const u32 histogram[256]) -> u8
 *
 * Computes a binarization threshold according to the Otsu's method for image
 * thresholding. Note that `len` correspond to the total number of pixels in the
 * image (w*h).
 */
u8 ComputeOtsuThreshold(size_t len, const u32 histogram[256]);

/*
 * AdaptiveThresholding(Image* img, u32* buf, size_t r, float threshold)
 *
 * Binarizes the input image using the adptive thresholding method that marks
 * all pixels that are at most off by `threshold` percent of the local mean as
 * dark (calculated in a window of `r` by `r`), otherwise as light. Note that
 * the thresholding inverts the light and dark values: dark is represented by a
 * pixel value of 255 and light by 0.
 */
void AdaptiveThresholding(Image* img, u32* buf, size_t r, float threshold);

/*
 * ThresholdImage(Image* image, u8 threshold)
 *
 * Binarizes the input image such that all pixels that are below the defined
 * threshold are considered as dark (255 in the output image because we invert
 * the values) and all values above are considered as bright (0 in the output
 * image).
 */
void ThresholdImage(Image* image, u8 threshold);
